<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>立直麻将向听数算法研究</title>
      <link href="/RiichiMahjongSyanten/"/>
      <url>/RiichiMahjongSyanten/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>在本文中，将对立直麻将中向听数的计算算法进行讨论，侧重于分析抽象的数学模型而非传统的牌理，阅读时请注意。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>向听数（シャンテン数），一般认为是「听牌的最小巡数」，对于七对子、国士无双以及一般型（四面子一雀头），可以分别定义为：</p><script type="math/tex; mode=display">\begin{aligned}\large\text{七对子向听数}&\large=6-\text{对子数}\\\large\text{国士无双向听数}&\large=13-\text{幺九种数}\\\large\text{一般型向听数}&\large=8-2*\text{面子数}-\text{对子数}-\text{搭子数}\\\end{aligned}</script><p>在多数情况下，手牌将会有多种拆分方式，并将其中求出的最小数值作为一副手牌的向听数。但是，依据上面的方式，我们必须得到手牌的所有拆分后才能进行计算，这将严重影响一类手牌（如染手）的分析效率。为了应对这一类问题，下文中将使用新的方法来定义并计算向听数。</p><h3 id="手牌与距离"><a href="#手牌与距离" class="headerlink" title="手牌与距离"></a>手牌与距离</h3><p>在本文中，我们将会用数字 $0-33$ 来分别表示 $123456789\text{m}123456789\text{p}123456789\text{s}1234567\text{z}$<br>对于一副手牌，则使用 $\mathbf{h}$ 表示，它的含义的第 $i\in[0,33]$ 张牌的数量为 $h_i$。</p><p>那么对于任意一副手牌 $\mathbf{h,g}$ ，定义它们的距离为：</p><script type="math/tex; mode=display">d(\mathbf{h,g})=\frac12\sum_{i=0}^{33}\left(|h_i-g_i|+h_i-g_i\right)\tag{1}</script><h3 id="定义的推广"><a href="#定义的推广" class="headerlink" title="定义的推广"></a>定义的推广</h3><p>正如前文提到，为了避免拆分牌型而造成运算时间的额外花费，我们对向听数进行新的定义。<br>记 $U$ 为所有和了型的集合，那么对于手牌 $\mathbf{h}$ ，它的向听数即为：</p><script type="math/tex; mode=display">S(\mathbf{h})=D(\mathbf{h})-1=\min_{\mathbf{u}\in U}d(\mathbf{u,h})-1</script><p>如此，所有的标准型（一般型+七对+国士）均可使用上式计算。</p><h3 id="计算向听数"><a href="#计算向听数" class="headerlink" title="计算向听数"></a>计算向听数</h3><p>为了方便讨论，本文只讨论一般型的 $D(\mathbf{h})$ 计算，七对子和国士无双可以通过特判更轻松的解决。<br>定义 $P_n^m$ 为 $n$ 个面子组成的手牌的集合，$Q_n^m$ 为 $n$ 个面子加 $1$ 个雀头组成的手牌的集合，上标 $m$ 表示该集合中所有牌的花色，$0-3$ 代表 $\text{mpsz}$。</p><p>先考虑一类简单的情况，手牌 $\mathbf{h}$ 只由 $2$ 种花色的牌构成，那么 $U$ 可以表示为一系列集合的笛卡尔积的并，即：</p><script type="math/tex; mode=display">U_2=\bigcup_{i=0}^4\bigcup_{j=0}^3\bigcup_{k=j}^3\left(P_i^j\times Q_{4-i}^k\right)</script><p>结合上文，可以将 $(1)$ 式变形为：</p><script type="math/tex; mode=display">\begin{aligned}D(\mathbf{h})&=\min_{\mathbf{u}\in U_2}d(\mathbf{u,h})\\&= \min_{0\le i\le4}\ \min_{0\le j\le k\le3} \left\{\min_{\mathbf{p}\in P_i^j,\mathbf{q}\in Q_{4-i}^k}d(\mathbf{p+q,h})\right\}\\\end{aligned}\tag{2}</script><p>单独考虑其中的某一项：</p><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{p}\in P_1^1,\mathbf{q}\in Q_3^2} d(\mathbf{p+q,h})&=\min_{\mathbf{p}\in P_1^1,\mathbf{q}\in Q_3^2}\frac12\left[\sum_{i=9}^{17}\left(|p_i-h_i|+p_i-h_i\right)+\sum_{i=18}^{26}\left(|q_i-h_i|+q_i-h_i\right)\right]\\&=\min_{\mathbf{p}\in P_1^1}\frac12\sum_{i=9}^{17}\left(|p_i-h_i|+p_i-h_i\right)+\min_{\mathbf{q}\in Q_3^2}\frac12\sum_{i=18}^{26}\left(|q_i-h_i|+q_i-h_i\right)\\\end{aligned}\tag{3}</script><p>不难发现，$D(\mathbf{h})$ 被拆分为<strong>局部向听数</strong>之和，由此我们将其定义为：</p><script type="math/tex; mode=display">\begin{aligned}r_n^m = \min_{\mathbf{p}\in P_n^m}\frac12\sum_{i=9n}^{9n+8}\left(|p_i-h_i|+p_i-h_i\right)\\s_n^m = \min_{\mathbf{q}\in Q_n^m}\frac12\sum_{i=9n}^{9n+8}\left(|q_i-h_i|+q_i-h_i\right)\\\end{aligned}\tag{4}</script><p>注意，当 $n=3$ 时，求和上限为 $9n+6$。<br>根据 $(4)$ 式，我们可以进一步简化 $(2)(3)$ 式，即：</p><script type="math/tex; mode=display">\begin{aligned}&\min_{\mathbf{p}\in P_1^1,\mathbf{q}\in Q_3^2} d(\mathbf{p+q,h})=r_1^1+s_3^2\\\Rightarrow\quad& D(\mathbf{h})=\min_{0\le i\le4}\ \min_{0\le j\le k\le3}\left\{r_i^j+s_{4-i}^k\right\}\end{aligned}</script><p>运用简单的动态规划思想，不难把上述内容推广到 $4$ 种花色的情况，此时有：</p><script type="math/tex; mode=display">\begin{aligned}&r_n^{\overline{m}}=\min_{0\le k\le n}\left\{r_k^{\overline{m-1}}+s_{n-k}^{m},s_k^{\overline{m-1}}+r_{n-k}^{m}\right\}\\&s_n^{\overline{m}}=\min_{0\le k\le n}\left\{s_k^{\overline{m-1}}+s_{n-k}^{m}\right\}\\&r_n^{\overline{0}}=r_n^0,\quad s_n^{\overline{0}}=s_n^0,\quad D(\mathbf{h})=r_4^{\overline{3}}\end{aligned}</script><p>预处理出值存储在文件中，即可快速计算向听数，代码实现见 <a href="https://github.com/SilveryStar/riichi-mahjong-syanten" target="_blank" rel="noopener">GitHub仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 麻将 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论算法</title>
      <link href="/BasicNumberTheory/"/>
      <url>/BasicNumberTheory/</url>
      
        <content type="html"><![CDATA[<h3 id="整除与同余"><a href="#整除与同余" class="headerlink" title="整除与同余"></a>整除与同余</h3><p>设 $a$ 为非零整数，$b$ 为整数，若存在 $q\in \mathbb{Z}$ 使得 $b=aq$ ，那么称 $b$ 被 $a$ 整除，记为 $a|b$ ，此时称 $b$ 为 $a$ 的倍数， $a$ 为 $b$ 的约数<br>整除满足以下性质：<br>$\text{1.}\;$ 若 $a|b$ 且 $b|c$ ，那么 $a|b$<br>$\text{2.}\;$ 若 $a|b$ 且 $b|c$ ，对于任意的 $x,\,y\in \mathbb{Z}$ ，有 $a|(bx+cy)$<br>$\text{3.}\;$ 若 $a|b$ 且 $m\in \ne 0$ ，那么 $ma|mb$<br>$\text{4.}\;$ 若对于 $x,\,y\in \mathbb{Z}$ 满足 $ax+by=1$ ，且 $a|n,\,b|n$ ，那么 $ab|n$<br>$\text{5.}\;$ 若 $b=pd+c$ ，当且仅当 $d|c$ 成立时有 $d|b$ 成立</p><p>对于两个整数 $a,\,b$ ，若存在 $m|(a-b),\,\, m\in \mathbb{Q}$ ，那么称 $a$ 在模 $m$ 意义下与 $b$ 同余，记为</p><script type="math/tex; mode=display">a\equiv b \mod m \Leftrightarrow a-b=mk,\,\, k\in \mathbb{Q}</script><p>同余满足以下性质：<br>$\text{1.}\;$ $a\equiv a \bmod m$<br>$\text{2.}\;$ 若 $a\equiv b\bmod m$ ，那么 $b\equiv a\bmod m$<br>$\text{3.}\;$ 若 $a\equiv b\bmod m$ 且 $b\equiv c\bmod m$ ，则 $a\equiv c\bmod m$<br>$\text{4.}\;$ 若 $a\equiv b\bmod m$ ，那么 $a+c\equiv b+c\bmod m$<br>$\text{5.}\;$ 若 $a\equiv b\bmod m$ ，那么 $ac\equiv bc\bmod m$<br>$\text{6.}\;$ 若 $a\equiv b\bmod m$ 且 $c\equiv d\bmod m$ ，则 $ac\equiv bd\bmod m$<br>$\text{7.}\;$ 若 $a\equiv b\bmod m$ ，那么 $a^n\equiv b^n\bmod m$<br>$\text{8.}\;$ $a\times b\bmod m=(a\bmod m) \times (b\bmod m)\mod m$<br>$\text{9.}\;$ $(a\pm b)\bmod m=\left((a\bmod m) \pm (b\bmod m)\right)\mod m$</p><p><strong>注意：</strong> 等式 $\frac{a}{b}\bmod m=\frac{a\bmod m}{b\bmod m}\bmod m$ 不恒成立</p><h3 id="快速幂与快速积"><a href="#快速幂与快速积" class="headerlink" title="快速幂与快速积"></a>快速幂与快速积</h3><p>快速幂常用于求形如  $a^x\bmod p$  的式子</p><p>考虑对指数进行二进制拆分，如</p><script type="math/tex; mode=display">a^{11}=a^{(1011)_2}=a^{(1000)_2}*a^{(10)_2}*a^{(1)_2}=a^8*a^2*a^1</script><p>那么进行计算时，可以考虑分别计算出 $a^1,\,a^2\dots a^{2^k}$ ，然后判断指数 $x$ 的第 $k$ 位二进制是否为 $1$ 即可判断此时是否需要乘上 $a^{2^{(k-1)}}$ ，时间复杂度为 $O(\log n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans*a % mod;</span><br><span class="line">        a = a*a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>快速幂在计算时存在一个问题，那就是当模数较大时，两数相乘极有可能超过超长整形的范围，此时还需要快速乘来辅助以避免精度问题，快速乘与快速幂的思想类似，对乘数进行二进制拆分，然后判断是否需要相乘，具体过程参见代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans+a) % mod;</span><br><span class="line">        a = (a+a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般的，当 $mod\ge 2\times 10^9$ 时，考虑在运行快速幂使用快速乘</p><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>欧几里得算法是一种用来求两数最大公因数的算法，运用辗转相除法，公式为</p><script type="math/tex; mode=display">\begin{aligned}\gcd(a,\,b)&=\gcd(b,\,a\bmod b) \\\gcd(a,\,0)&=a\end{aligned}</script><p>这个步骤可以简单的递归进行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过欧几里得算法也可以判断两数是否互质，当 $\gcd(a,\,b)=1$ 时， $a$ 与 $b$ 互质</p><p>关于最小公倍数，同样可以用欧几里得算法求解</p><script type="math/tex; mode=display">\text{lcm}(a,\,b)=\frac{ab}{\gcd(a,\,b)}</script><p>下面给出欧几里得算法的简要证明：<br>首先记 $d=\gcd(a,\,b)$，令 $a=k_1d,\ b=k_2d$， 设 $a=k*b+c$ ，即 $c$ 为余数，也就是 $c=a\bmod b$ ，考虑对上式移项并将值带入式子，得到</p><script type="math/tex; mode=display">c=k_1d-k*k_2d=(k_1-k*k_2)\,d</script><p>也就是说， $a$ 与 $b$ 的余数 $c$ 存在 $d$ 这个约数，所以 $\gcd(a,\,b)$ 是 $b$ 与 $a\bmod b$ 的一个公约数<br>我们知道 $a\bmod b=(k_1-k * k_2)\,d,\ b=k_2d$ ，为了证明 $\gcd(a,\,b)$ 的最大性，只需证明</p><script type="math/tex; mode=display">\gcd(k_2,\,k_1-k*k_2)=1</script><p>利用反证法，假设 $k_1-kk_2=qt,\ k_2=pt$ ，其中 $t&gt;1$ ，即 $k_2$ 与 $k_1-k*k_2$ 不互质，我们将前一个式子移项，得</p><script type="math/tex; mode=display">k_1=qt+k*k_2</script><p>将 $k_1$ 带入 $a=k_1d$ ，得到</p><script type="math/tex; mode=display">a=(qt+k*k_2)\,d=qtd+k*k_2d=qtd+k*b</script><p>又存在</p><script type="math/tex; mode=display">b=k_2d=ptd</script><p>所以</p><script type="math/tex; mode=display">a=qtd+k*b=qtd+k*ptd=(q+k*p)\,td</script><p>发现此时 $a$ 与 $b$ 存在一个约数 $td&gt;d$ ，假设不成立，即反证成功</p><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>扩展欧几里得算法是用于求解形如  $ax+by=\gcd(a,\,b)$  方程的一组解的算法</p><p>当 $b=0$ 时，原方程的解为 ${x=1,\,y=0}$<br>当 $b\ne 0$ 时，我们令 $a=b,\ b=a\mod b$ ，记此时 $x=x^{‘},\ y=y^{‘}$ ，那么原方程变为</p><script type="math/tex; mode=display">bx^{'}+(a\bmod b)y^{'}=\gcd(b,\,a\bmod b)=\gcd(a,\,b)</script><p>那么只需像欧几里得算法那样递归缩小 $a$ 与 $b$ 的值即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = exgcd(b, a%b, x, y);</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp - a/b * y;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当需求解任意一个不定方程 $ax+by=c$ 时，其有解的充要条件是 $\gcd(a,\,b)|c$ ，此时方程存在无数组解，否则无解<br>利用扩展欧几里得算法我们能得到不定方程的一组特解，即为 $x_1,\, y_1$ ，那么通解为</p><script type="math/tex; mode=display">\begin{cases}x = x_1+k*\frac{b}{\gcd(a,b)} \\y = y_1-k*\frac{a}{\gcd(a,b)}\end{cases}</script><h3 id="模线性方程组"><a href="#模线性方程组" class="headerlink" title="模线性方程组"></a>模线性方程组</h3><p>模线性方程组形如：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a \mod n \\x \equiv b \mod m\end{cases}</script><p>试求解 $x$，考虑将该式变形为</p><script type="math/tex; mode=display">\begin{cases}x = np+a \\x = mq+b\end{cases}</script><p>联立变形得</p><script type="math/tex; mode=display">\begin{aligned}np+a&=mq+b \\np+(-m)\,q &= b-a\end{aligned}</script><p>显然下面是一个不定方程的形式，使用扩展欧几里得算法求解即可</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>对于一个素数 $p$ ，若 $\gcd(a,\,p)=1$ ，那么存在</p><script type="math/tex; mode=display">a^{p-1}\equiv 1\mod p</script><p><strong>注意：</strong> 费马小定理的逆命题不一定成立</p><p>费马小定理的简洁证明：<br>设一个素数 $p$ 和一个非负整数 $m$ ，那么恒存在</p><script type="math/tex; mode=display">\begin{aligned}(m+1)^p&=\sum\limits_{i=0}^pC_p^im^{p-i} \\&\equiv m^p+1 \mod p\end{aligned}</script><p>等价于</p><script type="math/tex; mode=display">(m+1)^p-m^p\equiv 1 \mod p</script><p>令 $m=0,\,1,\,2,\,3\dots a-1$ ，得</p><script type="math/tex; mode=display">\begin{aligned}1^p-0^p &\equiv 1 \mod p \\2^p-1^p &\equiv 1 \mod p \\3^p-2^p &\equiv 1 \mod p \\&\,\,\,\vdots \\a^p-(a-1)^p &\equiv 1 \mod p\end{aligned}</script><p>上述各式相加，得</p><script type="math/tex; mode=display">a^p\equiv a \mod p</script><p>整理得</p><script type="math/tex; mode=display">a^{p-1}\equiv 1 \mod p</script><h3 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h3><p>如果存在一个素数 $p$ 和一个数 $x\in (0,\,p)$ ，那么存在一个方程</p><script type="math/tex; mode=display">x^2\equiv 1\mod p</script><p>存在两解 $x=1$ 或 $x=p-1$</p><p>二次探测定理的简洁证明:</p><script type="math/tex; mode=display">\begin{aligned}&x^2\equiv 1\mod p \\\Rightarrow \;&x^2-1=(x-1)\,(x+1)\equiv 0\mod p \\\Rightarrow \;&p|(x-1)(x+1)\end{aligned}</script><p>因为 $p$ 为素数，那么可知 $x=1$ 或 $x=p-1$</p><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>由上文可知，模计算不满足同除性，那么我们定义一个数 $a$ 模 $p$ 意义下的逆元为 $a^{-1}$ ，其满足</p><script type="math/tex; mode=display">a\times a^{-1}\equiv 1 \mod p</script><p>于是对于一个形如</p><script type="math/tex; mode=display">\frac{a}{b}\mod p</script><p>的式子，现定义其取模运算等价于</p><script type="math/tex; mode=display">\frac{a}{b}=a\times b^{-1}\mod p</script><p>只需求出 $b$ 的逆元即可得到这个式子的结果</p><p>关于求解逆元，有三种方式：</p><h4 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h4><p>对整数 $a$ 和模数 $p$ 求解一个不定方程</p><script type="math/tex; mode=display">ax+py=\gcd(a,\,p)</script><p>最后求出的 $x\bmod p$ 即为逆元，时间复杂度 $O(\log n)$<br>此处的 $x$ 可能为负，为了得到正逆元需要进行处理</p><h4 id="费马小定理-1"><a href="#费马小定理-1" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>费马小定理提出</p><script type="math/tex; mode=display">a^{p-1}\equiv 1\mod p</script><p>那么只需将该式变形，得</p><script type="math/tex; mode=display">a\times a^{-1}\equiv a\times a^{p-2}\equiv 1 \mod p</script><p>此时 $a^{p-2}$ 即为逆元，快速幂即可求出，时间复杂度 $O(log\,p)$</p><h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><p>考虑一个模数 $p$ ，存在</p><script type="math/tex; mode=display">p\equiv \left\lfloor \frac{p}{i}\right\rfloor i + p\bmod i\equiv 0 \mod p</script><p>将 $p\bmod i$ 移项，得</p><script type="math/tex; mode=display">\left\lfloor \frac{p}{i}\right\rfloor i \equiv -(p\bmod i) \mod p</script><p>两边同时乘以 $-(p\,\%\,i)$ 模 $p$ 意义下的逆元</p><script type="math/tex; mode=display">-(p\bmod i)^{-1}\left\lfloor \frac{p}{i}\right\rfloor i \equiv 1 \mod p</script><p>两边同时乘以 $i$ 模 $p$ 意义下的逆元，整理得</p><script type="math/tex; mode=display">i^{-1}\equiv-\left\lfloor \frac{p}{i}\right\rfloor(p\bmod i)^{-1} \mod p</script><p>其中 $\left\lfloor \frac{p}{i}\right\rfloor$ 可以直接求得，又由于 $p\bmod i&lt;i$ ，所以可以通过线性递推的方式处理出 $[\,1,\,n\,]$ 中所有数的逆元，时间复杂度 $O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span><span class="params">(<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=range; i++)</span><br><span class="line">        inv[i] = (<span class="number">1l</span>l*(p-p/i)*inv[p%i]) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h4 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h4><p>对于任意一个数 $x$ ，一定可以被表示为</p><script type="math/tex; mode=display">x=\prod\limits_{i=1}^k p_i^{c_i}</script><p>其中 $p_i$ 为素数</p><h4 id="判定法"><a href="#判定法" class="headerlink" title="判定法"></a>判定法</h4><p>素数朴素判定法，对于正整数 $x$ 考虑枚举所有的 $k\le \sqrt{x}$ ，若始终存在 $k|x$ ，那么 $x$ 即为一个素数，判断复杂度 $O(\sqrt{n})$</p><p>$\text{Miller-Rabin}$ 判定法，对于一个待判断的整数 $p$ ，若存在一个底数 $a$ ，使得</p><script type="math/tex; mode=display">a^{p-1}\ne 1\mod p</script><p>由费马小定理得，这个数必然不为素数<br>对这个结论进行加强，设 $p-1=k\times 2^d$ ，设 $d^{‘}\in[\,0,\,d\,)$，若</p><script type="math/tex; mode=display">\begin{aligned}a^{k\times 2^{d^{'}}}\equiv p-1\mod p\\a^{k\times 2^{d^{'}}}\equiv 1\mod p\end{aligned}</script><p>中任意一式成立，由二次探测定理和费马小定理可得知，$p$ 可能是素数<br>可以证明，每一次判定失误的概率约为 $\frac{1}{4}$ ，多次判定即可提高正确率，时间复杂度 $O(\log n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">2</span> || !(p &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> k = p<span class="number">-1</span>, d = <span class="number">0</span>, y;</span><br><span class="line">    <span class="keyword">while</span>(!(k &amp; <span class="number">1</span>))</span><br><span class="line">        d++, k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">10</span> &amp;&amp; prime[i] &lt; p; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = prime[i];</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">pow</span>(a, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=d; j++)&#123;</span><br><span class="line">            y = <span class="built_in">pow</span>(x, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != p<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>筛法</strong><br>朴素筛，使用朴素判断法进行筛选，时间复杂度 $O(n\sqrt{n})$</p><p>埃氏筛，对于一个已知的素数，通过枚举的方式在范围内筛去所有该数的倍数，最后得到的就是合法的素数表，时间复杂度为 $O(\,\sum\limits_{p&lt;n}\frac{n}{p}\,)=O(n\log\log n)$</p><p>欧拉筛，又名线性筛，在埃氏筛筛数的过程中我们发现，数字 $6$ 被 $2$ 和 $3$ 各筛选了一次，浪费了时间，考虑优化这一点<br>对于一个合数 $a$ ，我们考虑将其分解</p><script type="math/tex; mode=display">a=p_1^{k_1}*p_2^{k_2}*p_3^{k_3}\dots* p_n^{k_n}</script><p>其中 $p_i&lt;p_j\,(i&lt;j)$ ，当我们使用 $prime_j$ 去筛选合数时，若 $p_1=prime_j$ 则终止筛选，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>考虑这么做的正确性，对于一个合数 $C$ 的最小素因子 $p_1$ ,令 $B=\frac{C}{p_1}$ ，则对于 $B$ 的最小素因子 $p_1^{‘}$ 一定存在 $p_1^{‘}\ge p_1$ ，否则 $C$ 就会存在更小的素因子，当循环外层枚举到 $i=B$ 时，我们从小到大枚举已知的所有素数，因为 $p_1^{‘}\ge p_1$ 所以 $i$ 在素数枚举到 $p_1$ 之间一定不会被跳出循环，最终 $C$ 一定会被 $B*p_1$ 筛去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_able</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> notPrime[n+<span class="number">1</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!notPrime[i])</span><br><span class="line">            prime[++num] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num &amp;&amp; i*prime[j] &lt; n; j++)&#123;</span><br><span class="line">            notPrime[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)    <span class="comment">// 欧拉筛核心</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排列与组合"><a href="#排列与组合" class="headerlink" title="排列与组合"></a>排列与组合</h3><p>给定 $n$ 个物品，将其取出 $m$ 个物品进行组合，考虑取出的顺序，那么总方案数为</p><script type="math/tex; mode=display">A_n^m=\frac{n!}{(n-m)!}</script><p>我们将 $A_n^m$ 称为一个排列</p><p>给定 $n$ 个物品，将其取出 $m$ 个物品进行组合，不考虑取出的顺序，那么总方案数为</p><script type="math/tex; mode=display">C_n^m=\frac{n!}{m!* (n-m)!}</script><p>我们将 $C_n^m$ 称为一个组合</p><p>组合数同样可以用于描述二项式的 $n$ 次幂公式</p><script type="math/tex; mode=display">(x+y)^n=\sum\limits_{i=0}^nC_n^ix^iy^{n-i}</script><p>该式被称为 <strong>二项式定理</strong><br>对于第 $i$ 项 $C_n^ix^iy^{n-i}$ ，可以理解为在 $n$ 个 $(x+y)$ 中取出 $i$ 个 $x$ 相乘得到 $C_n^i$ 个 $x$ 的 $i$ 次项</p><p>组合数还满足以下性质<br><strong>性质一</strong></p><script type="math/tex; mode=display">C_n^m=C_{n-1}^m+C_{n-1}^{m-1}</script><p><strong>性质二</strong></p><script type="math/tex; mode=display">C_n^m=C_n^{n-m}</script><p><strong>性质三</strong></p><script type="math/tex; mode=display">C_{n+r+1}^r=\sum\limits_{i=0}^{r}C_{n+i}^i</script><p><strong>性质四</strong></p><script type="math/tex; mode=display">\sum\limits_{i=0}^n(-1)^{i}C_n^i=0</script><p><strong>性质五</strong></p><script type="math/tex; mode=display">\sum\limits_{i=0}^nC_n^i=(1+1)^n=2^n</script><p><strong>性质六</strong></p><script type="math/tex; mode=display">C_{n+m}^r=\sum\limits_{i=0}^rC_m^i*C_n^{r-i}</script><p><strong>性质七</strong></p><script type="math/tex; mode=display">m*C_n^m=n*C_{n-1}^{m-1}</script><p><strong>性质八</strong></p><script type="math/tex; mode=display">\sum\limits_{i=0}^n(C_n^i)^2=C_{2n}^n</script><p><strong>卢卡斯定理</strong><br>对于素模数 $p$ ，存在</p><script type="math/tex; mode=display">Lucas_n^m\equiv C_{n\bmod p}^{m\bmod p} * Lucas_{n/p}^{m/p}\mod p</script><p>$\text{Lucas}$ 定理的简单实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n%p, m%p, p)*Lucas(n/p, m/p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>给定一个同余方程组</p><script type="math/tex; mode=display">x \equiv a_i\mod m_i\,\,\,\,i\in [\,1,\,n\,]</script><p>且保证</p><script type="math/tex; mode=display">\gcd(m_i,\,m_j)=1\,\,\,\,i\ne j</script><p>恒成立，试求出 $x$ 的一个可行解</p><p>我们设</p><script type="math/tex; mode=display">\begin{aligned}M=\prod\limits_{i=1}^nm_i,\,\, \ g_i=\frac{M}{m_i} \\k_i*g_i\equiv 1 \mod m_i\end{aligned}</script><p>那么存在一组可行解为</p><script type="math/tex; mode=display">x= \left(\sum\limits_{i=1}^na_ik_ig_i\right)\bmod M</script><p>该解使用构造法求得，将其带入原方程不难发现它是正确的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">crt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, M = <span class="number">1</span>, k, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        M = M*m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> g = M/m[i];</span><br><span class="line">        exgcd(g, m[i], k, y);</span><br><span class="line">        k = (k%m[i]+m[i]) % m[i];</span><br><span class="line">        ans = (ans+k*g*a[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p>给定一个同余方程组</p><script type="math/tex; mode=display">x \equiv a_i\mod m_i\,\,\,\,i\in [\,1,\,n\,]</script><p>且 <strong>不保证</strong></p><script type="math/tex; mode=display">\gcd(m_i,\,m_j)=1\,\,\,\,i\ne j</script><p>恒成立，试求出 $x$ 的一个可行解</p><p>对于不互素的模数求解同余方程组时，中国剩余定理不再适用</p><p>假设我们现在已经求出前 $k-1$ 个同余方程组的的一个可行解 $x$，设</p><script type="math/tex; mode=display">M=\prod_{i=1}^{k-1}m_i</script><p>则前 $k-1$ 个同余方程组的通解为 $x+p*M\,\,,p\in \mathbb{Z}$<br>那么加入第 $k$ 个方程组后，为了解出新的可行解，等价于要求存在一个正整数 $t$ ，满足</p><script type="math/tex; mode=display">x+t*M\equiv a_k\mod m_k</script><p>整理得</p><script type="math/tex; mode=display">t*M\equiv a_k-x\mod m_k</script><p>对这个式子运用扩展欧几里得算法求解即可得到 $t$ ，若该式无解，则方程组无解，否则前 $k$ 个方程组的一个可行解为</p><script type="math/tex; mode=display">x^{'}=x+t*M</script><p>于是扩展中国剩余定理即可转化为求 $n$ 次扩展欧几里得</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, k, gcd;</span><br><span class="line">    <span class="keyword">int</span> M = m[<span class="number">1</span>], ans = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = ((a[i]-ans)%m[i]+m[i]) % m[i];</span><br><span class="line">        gcd = exgcd(M, m[i], x, y);</span><br><span class="line">        <span class="keyword">if</span>(p % gcd) <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// 不互素，无解</span></span><br><span class="line">        m[i] /= gcd;</span><br><span class="line">        x = x*(p/gcd) % m[i];</span><br><span class="line">        ans += x*M;</span><br><span class="line">        M = M*m[i];</span><br><span class="line">        ans = (ans%M+M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans%M+M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>对于素模数 $p$ ，存在</p><script type="math/tex; mode=display">(p-1)!\equiv -1\mod p</script><h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>定义一个函数 $f$ 是定义域为正整数的函数，对于任意满足 $\gcd(a,\,b)=1$ 的两数 $a,\,b$ ，若满足</p><script type="math/tex; mode=display">f(ab)=f(a) * f(b)</script><p>则称函数 $f$ 为积性函数</p><p>一些简单的积性函数<br><strong>常值函数</strong></p><script type="math/tex; mode=display">1(n)=1</script><p><strong>单位函数</strong></p><script type="math/tex; mode=display">\epsilon(n)=[n=1]=\begin{cases}1, &n=1 \\0, &n>1\end{cases}</script><p><strong>恒等函数</strong></p><script type="math/tex; mode=display">\begin{aligned}Id(n)&=n \\Id_k(n)&=n^k\end{aligned}</script><p><strong>正因子函数</strong></p><script type="math/tex; mode=display">d(n)=\sum\limits_{d|n}1</script><p><strong>因子和函数</strong></p><script type="math/tex; mode=display">\sigma(n)=\sum\limits_{d|n}d</script><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>欧拉函数表示对于一个正整数 $x$ ，所有不大于 $x$ 且与 $x$ 互素的数的个数，记为 $\varphi(x)$</p><script type="math/tex; mode=display">\varphi(x)=\sum\limits_{i=1}^x[\gcd(i,\,x)=1]</script><p>根据唯一分解定义，存在</p><script type="math/tex; mode=display">x=\prod\limits_{i=1}^k p_i^{c_i}</script><p>那么</p><script type="math/tex; mode=display">\varphi(x)=\prod_{i=1}^k(p_i-1)p_i^{c_i-1}</script><p>欧拉函数还满足以下性质<br><strong>性质一</strong></p><script type="math/tex; mode=display">\sum\limits_{d|n}\varphi(d)=n</script><p><strong>性质二</strong><br>对于素数 $p$ ，存在</p><script type="math/tex; mode=display">\varphi(p)=p-1</script><p>对于 $n=p^k$ ，存在</p><script type="math/tex; mode=display">\varphi(n)=p^k-p^{k-1}</script><p><strong>性质三</strong><br>欧拉函数是积性函数，即存在 $a,\,b$ 满足 $\gcd(a,\,b)=1$ 时，恒存在</p><script type="math/tex; mode=display">\varphi(ab)=\varphi(a)\,\varphi(b)</script><p>特别的，当 $a=2$ 时，</p><script type="math/tex; mode=display">\varphi(2b)=\varphi(b)</script><p>故欧拉函数不是完全积性函数</p><p><strong>性质四</strong></p><script type="math/tex; mode=display">\sum\limits_{\gcd(i,\,n)=1}i=\frac{\varphi(n)* n}{2}</script><p><strong>性质五</strong><br>当 $n&gt;2$ 时，有 $\varphi(n)\equiv 0\mod 2$ 恒成立</p><p><strong>欧拉定理</strong><br>若 $\gcd(a,\,p)=1$ ，那么</p><script type="math/tex; mode=display">a^{\varphi(p)}\equiv 1\mod p</script><p>关于求解欧拉函数值，同样可以使用欧拉筛，根据欧拉函数性质即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, prime[range+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> notPrime[range+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> phi[range+<span class="number">1</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=range; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!notPrime[i])&#123;</span><br><span class="line">            prime[++num] = i;</span><br><span class="line">            phi[i] = i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=num &amp;&amp; i*prime[j]&lt;range; j++)&#123;</span><br><span class="line">            notPrime[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))&#123;</span><br><span class="line">                phi[i*prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="comment">// 欧拉函数的积性</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i*prime[j]] = phi[i] * (prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>莫比乌斯函数是一类容斥系数，被定义为</p><script type="math/tex; mode=display">\mu(n)=\begin{cases}1 &n=1\\(-1)^k &\forall a,\,a^2 \nmid n;\,n=p_1p_2\dots p_k\\0 &\exists a,\,a^2\, | n\end{cases}</script><p>莫比乌斯函数存在一个重要的性质</p><script type="math/tex; mode=display">\sum\limits_{d|n}\mu(d)=[n=1]</script><p><strong>莫比乌斯反演</strong><br>对于两个函数 $F,\,f$ ，若存在如下关系</p><script type="math/tex; mode=display">F(n)=\sum\limits_{d|n}f(d)</script><p>那么就有</p><script type="math/tex; mode=display">f(n)=\sum\limits_{d|n}\mu(\frac{n}{d})F(d)</script><h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>我们定义卷积运算符 $(* )$ ，那么两个函数 $f,\,g$ 的狄利克雷卷积为</p><script type="math/tex; mode=display">(f*g)(n)=\sum\limits_{d|n}f(d)g(\frac{n}{d})</script><p>狄利克雷卷积存在一个重要的性质，即当 $f,\,g$ 均为积性函数时， $f*g$ 也为积性函数</p><h3 id="大步小步算法"><a href="#大步小步算法" class="headerlink" title="大步小步算法"></a>大步小步算法</h3><p>大步小步 $\text{(BSGS, Baby Step Gaint Step)}$ 算法<br>已知高次同余方程</p><script type="math/tex; mode=display">A^x\equiv B \mod C</script><p>试求解 $x$ 的值</p><p>令 $S=\lfloor\sqrt{C}\rfloor$ ，记 $x=iS+j$ ，则原式变为</p><script type="math/tex; mode=display">A^{iS+j}\equiv B \mod C</script><p>整理得</p><script type="math/tex; mode=display">A^{j}\equiv B*A^{-iS}\mod C</script><p>我们循环 $j=0\to S-1$ ，将 $(A^j\bmod C,\,j)$ 加入一个 $\text{Hash}$ 表中，再枚举 $(B*A^{-iS})\bmod C$ 查看该值是否存在于 $\text{Hash}$ 表中，若找到 $text{Hash}$ 表中存在 $(i,\,j)$ ，那么据 $x=iS+j$ 即可得到正确解<br>当然 $\text{Hash}$ 也可以使用 <code>std::map</code> 代替<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(A % C)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    Hash.clear();</span><br><span class="line">    S = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C));</span><br><span class="line">    <span class="keyword">int</span> tmp = B % C;</span><br><span class="line">    Hash[tmp] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=S; i++)&#123;</span><br><span class="line">        tmp = (tmp*A) % C;</span><br><span class="line">        Hash[tmp] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">pow</span> = qpow(A, S); tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=S; i++)&#123;</span><br><span class="line">        tmp = (tmp*<span class="built_in">pow</span>) % C;</span><br><span class="line">        <span class="keyword">if</span>(Hash[tmp])</span><br><span class="line">            <span class="keyword">return</span> ((i*S-Hash[tmp])%C+C) % C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩展大步小步算法"><a href="#扩展大步小步算法" class="headerlink" title="扩展大步小步算法"></a>扩展大步小步算法</h3><p>在上文中的大步小步算法中，不难发现合法的充要条件为 $\gcd(A,\,C)=1$ ，否则无法求得正解，扩展大步小步算法就是解决 $\gcd(A,\,C)\ne 1$ 的一类高次同余方程</p><p>设 $d=\gcd(A,\,C)$ ，假设 $d|B$ ，等价于</p><script type="math/tex; mode=display">\frac{A}{d}\times A^{x-1}\equiv \frac{B}{d}\mod \frac{C}{d}</script><p>不难发现，数据范围被我们缩小了，只需重复该过程，直至 $\gcd(A,\,C)=1$ ，此时可以使用原式大步小步算法求解了</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>我们定义一个数列 $F$ ，其中 $F_1=F_2=1$ ，对于 $n&gt;2$ ，满足</p><script type="math/tex; mode=display">F_n=F_{n-1}+F_{n-2}</script><p><strong>斐波那契的通项公式</strong><br>设常数 $r,\,s$ ，使得</p><script type="math/tex; mode=display">F_n-rF_{n-1}=s*(F_{n-1}-rF_{n-2})</script><p>移项整理得</p><script type="math/tex; mode=display">\begin{aligned}r+s=1 \\-rs=1\end{aligned}</script><p>当 $n\ge3$ 时，有</p><script type="math/tex; mode=display">\begin{aligned}F_n-rF_{n-1}&=s*(F_{n-1}-rF_{n-2})\\F_{n-1}-rF_{n-2}&=s*(F_{n-2}-rF_{n-3})\\F_{n-2}-rF_{n-3}&=s*(F_{n-3}-rF_{n-4})\\&\;\;\vdots\\F_3-rF_2&=s*(F_2-rF_1)\end{aligned}</script><p>联立上面的 $n-2$ 个式子，得</p><script type="math/tex; mode=display">F_n-rF_{n-1}=s^{n-2}* (F_2-rF_1)</script><p>因为</p><script type="math/tex; mode=display">s=1-r,\;F_1=F_2=1</script><p>所以上式化简为</p><script type="math/tex; mode=display">F_n=s^{n-1}+rF_{n-1}</script><p>迭代该式，得</p><script type="math/tex; mode=display">F_n=\sum\limits_{i=1}^{n}s^{n-i}r^{i-1}</script><p>这是一个以 $s^{n-1}$ 为首项， $r^{n-1}$ 为末项且公比 $q=\frac{r}{S}$ 的等比数列的和，根据等比和公式得</p><script type="math/tex; mode=display">\begin{aligned}\large F_n&=\frac{s^{n-1}-r^{n-1}\frac{r}{s}}{1-\frac{r}{s}} \\&= \frac{s^n-r^n}{s-r}\end{aligned}</script><p>由于</p><script type="math/tex; mode=display">\begin{aligned}r+s=1 \\-rs=1\end{aligned}</script><p>存在一组解</p><script type="math/tex; mode=display">s=\frac{1+\sqrt{5}}{2},\;r=\frac{1-\sqrt{5}}{2}</script><p>则</p><script type="math/tex; mode=display">F_n=\frac{\sqrt{5}}{5}\left[\left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n\right]</script><h3 id="卡特兰数列"><a href="#卡特兰数列" class="headerlink" title="卡特兰数列"></a>卡特兰数列</h3><p><strong>递归公式</strong></p><script type="math/tex; mode=display">f(n)=\sum\limits_{i=0}^{n-1}f(i)f(n-i-1)</script><script type="math/tex; mode=display">f(n)=\frac{(4n-2)* f(n-1)}{n+1}</script><p><strong>组合公式</strong></p><script type="math/tex; mode=display">f(n)=\frac{C_{2n}^{n}}{n+1}</script><script type="math/tex; mode=display">f(n)=C_{2n}^{n}-C_{2n}^{n-1}</script><p><strong>数学意义</strong><br>卡特兰数通常表示为 $n$ 个元素全部入栈全部出栈所有可能顺序，也可以被引申为以下含义：<br>$n$ 个节点组成的二叉树的数量，可以把左子节点可以理解为入栈，右子节点理解为出栈<br>$n$ 左括号和右括号的匹配序列方案数，可以把左括号理解为入栈，右括号理解为出栈</p><p>特别的，$n$ 个顶点的凸多边形剖分为三角形也可以使用卡特兰数来表示</p><h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><p><strong>第一类斯特林数</strong><br>$n$ 个不同的元素构成 $m$ 个圆排列的方案数，记其为 $S(n,\,m)$ ，有递推公式</p><script type="math/tex; mode=display">S(n,\,m)=S(n-1,\,m)* (n-1)+S(n-1,\,m-1)</script><p>特别的，保证</p><script type="math/tex; mode=display">S(n,\,n)=1,\;S(n,\,0)=0</script><p><strong>第二类斯特林数</strong><br>将 $n$ 个不同的小球装进 $m$ 个无差别的盒子的总方案数，即为 $s(n,\,m)$ ,有递推公式</p><script type="math/tex; mode=display">s(n,\,m)=s(n-1,\,m)* m+s(n-1,\,m-1)</script><p>特别的，保证</p><script type="math/tex; mode=display">s(n,\,n)=1,\;s(n,\,0)=0</script><p>其还存在通项公式</p><script type="math/tex; mode=display">s(n,\,m)=\frac{1}{m!}\sum\limits_{k=0}^m(-1)^kC_m^k(m-k)^n</script>]]></content>
      
      
      <categories>
          
          <category> 算法解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题的拓展</title>
      <link href="/ExpansionBackpackProblem/"/>
      <url>/ExpansionBackpackProblem/</url>
      
        <content type="html"><![CDATA[<h3 id="混合背包模型"><a href="#混合背包模型" class="headerlink" title="混合背包模型"></a>混合背包模型</h3><h4 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h4><p>顾名思义，混合背包是由$01$背包、完全背包和多重背包组成的，共有 $n$ 种物品，有的只有 $1$ 个，有的有 $\infty$ 个，有的有 $num_i$ 个，对于第 $i$ 种物品，装进背包的代价为 $cost_i$ ，收益为 $value_i$ ，给定一个容量为 $V$ 的背包，试求最大的收益<br><a id="more"></a></p><h4 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h4><p>事实上，该类背包模型只是对于前文中三种模型的累加，只需判断并调用背包模板即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mix</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] == inf)</span><br><span class="line">            Complete(value[i], cost[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] == <span class="number">1</span>)</span><br><span class="line">            ZeroOne(value[i], cost[i]);</span><br><span class="line">        <span class="keyword">else</span> Multiple(value[i], cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二维代价背包模型"><a href="#二维代价背包模型" class="headerlink" title="二维代价背包模型"></a>二维代价背包模型</h3><h4 id="模型简介-1"><a href="#模型简介-1" class="headerlink" title="模型简介"></a>模型简介</h4><p>二维代价背包是指物品具有两种代价 $a$ 和 $b$ ，同时背包也具有两种容量 $V$ 和 $U$ ，要求取出物品的代价和均不超过两重容量的限制，求最大获得的收益</p><h4 id="模型分析-1"><a href="#模型分析-1" class="headerlink" title="模型分析"></a>模型分析</h4><p>由于代价多了一维，状态设计时也额外需要一维，设 $dp(i,\,j,\,k)$ 为取到第 $i$ 种物品时，背包两重代价分别使用了 $j$ 和 $k$ ，由此获得转移方程</p><script type="math/tex; mode=display">dp(i,\,j,\,k)=max\{dp(i-1,\,j,\,k),\,dp(i-1,\,j-a_i,\,k-b_i)+value_i\}</script><p>这类问题同样可以参考前文的方式将三维优化至二维转移，时间复杂度为 $O(\,nVU\,)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOne</span><span class="params">(<span class="keyword">int</span> cost1, <span class="keyword">int</span> cost2, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = V; i&gt;=cost1; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = U; j&gt;=cost2; j--)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i-cost1][j-cost2]+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complete</span><span class="params">(<span class="keyword">int</span> cost1, <span class="keyword">int</span> cost2, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cost1; i&lt;=V; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = cost2; j&lt;=U; j++)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i-cost1][j-cost2]+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiple</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost1, <span class="keyword">int</span> cost2, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; num) k = num;</span><br><span class="line">        ZeroOne(k*cost1, k*cost2, k*value);</span><br><span class="line">        num -= k;</span><br><span class="line">        k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="分组背包模型"><a href="#分组背包模型" class="headerlink" title="分组背包模型"></a>分组背包模型</h3><h4 id="模型简介-2"><a href="#模型简介-2" class="headerlink" title="模型简介"></a>模型简介</h4><p>分组背包中 $n$ 种物品被分为了 $k$ 组，每一组中的物品只能选择一件，求解最大收益</p><h4 id="模型分析-2"><a href="#模型分析-2" class="headerlink" title="模型分析"></a>模型分析</h4><p>考虑设计状态，由于每一组中最多只能选取一个物品，设 $dp(i,\,j)$ 表示取到第 $i$ 组物品，使用背包代价为 $j$ 时的最大收益，那么转移方程为</p><script type="math/tex; mode=display">dp(i,\,j)=max\{dp(i-1,\,j),\,dp(i-1,\,j-cost_i)+value_i\}</script><p>可以发现该转移方程与$01$背包相同，事实上，分组背包只是将一系列的物品捆绑在了一起，在一个集合中做了限制，所以解决分组背包问题时也仅需额外加一维枚举量对组进行枚举即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p&lt;=k; p++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = V; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j∈K[p]; j++)</span><br><span class="line">            dp[i] = max(dp[i], dp[i-cost[j]]+value[j]);</span><br></pre></td></tr></table></figure><br>值得关注的一点在于，该方程在转移时对背包容量的枚举必须在对物品的枚举之前，只有这样才能保证每组至多有一个物品被加入进了背包中<br>关于分组背包的优化问题，可以参考前文在对完全背包模型优化时提到的删物品的思想</p><h3 id="有依赖的背包模型"><a href="#有依赖的背包模型" class="headerlink" title="有依赖的背包模型"></a>有依赖的背包模型</h3><h4 id="模型简介-3"><a href="#模型简介-3" class="headerlink" title="模型简介"></a>模型简介</h4><p>顾名思义，有依赖的背包中每一种物品都可能依赖于另一种物品，即若要使得 $i$ 能被选取，当且仅当 $depend(i)$ 被选取</p><h4 id="模型分析-3"><a href="#模型分析-3" class="headerlink" title="模型分析"></a>模型分析</h4><p>不难发现，这种依赖关系本质上组成了物品与物品之间的树形结构，子节点被选取的必要条件是父节点被选取<br>更多的时候，该类模型仅作为一种 树型$\text{DP}$ 的思想，后文将在 <strong>例题与题解</strong> 中介绍这一种思想</p><h3 id="泛化物品模型"><a href="#泛化物品模型" class="headerlink" title="泛化物品模型"></a>泛化物品模型</h3><h4 id="模型简介-4"><a href="#模型简介-4" class="headerlink" title="模型简介"></a>模型简介</h4><p>在前面所有提到的背包模型中，$n$ 种物品都有各自给定的代价 $cost_i$ 与收益 $value_i$ ，而对于泛化物品， 不存在固定的代价与收益，它的收益随着分配的代价变化而变化<br>更严格的说，泛化物品对应的是一个收益函数 $h$ ，当给某件泛化物品分配大小为 $v$ 的代价时，该物品的收益为 $h(v)$</p><h4 id="模型分析-4"><a href="#模型分析-4" class="headerlink" title="模型分析"></a>模型分析</h4><p>先了解一个概念，泛化物品的和。给定两个泛化物品 $h$ 与 $l$ ，如何用给定的代价从它们中得到最大收益？简单枚举即可，设 $dp(i)$ 表示代价为 $i$ 时的最大收益，那么</p><script type="math/tex; mode=display">dp(i)=\max\limits_{k=0}^V\,h(k)+l(V-k)</script><p>那么就可以提取出求解泛化物品模型的一种方法，将泛化物品表示为若干个泛化物品的和分别求值即可</p><p>事实上，泛化物品模型本质上只是改固定的代价与收益为函数 $h$ ，在解决实际问题中，往往只需预处理出函数值即可套用其他的背包模型解决问题，而对于更加复杂的情况，则需要对题目具体分析</p><h3 id="例题与题解"><a href="#例题与题解" class="headerlink" title="例题与题解"></a>例题与题解</h3><h4 id="Luogu1507-NASA的食物计划"><a href="#Luogu1507-NASA的食物计划" class="headerlink" title="Luogu1507 NASA的食物计划"></a><a href="https://www.luogu.org/problemnew/show/P1507" target="_blank" rel="noopener">Luogu1507 NASA的食物计划</a></h4><p><strong>题目描述</strong><br>有 $n\le50$ 种食物，每种食物有体积、质量和卡路里三个数值，已知飞船最大能带的食物的体积数 $V\le400$ 和质量数 $M\le400$ ，若每种食物只能带一件，求最大的卡路里值</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,M,n,a,b,value;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">405</span>][<span class="number">405</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOne</span><span class="params">(<span class="keyword">int</span> cost1, <span class="keyword">int</span> cost2, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = V; i&gt;=cost1; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = M; j&gt;=cost2; j--)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i-cost1][j-cost2]+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;V,&amp;M,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;value);</span><br><span class="line">        ZeroOne(a, b, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[V][M]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="HDU2159-FATE"><a href="#HDU2159-FATE" class="headerlink" title="HDU2159 FATE"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2159" target="_blank" rel="noopener">HDU2159 FATE</a></h4><p><strong>题目描述</strong><br>$\text{XHD}$ 离升到最后一级只剩 $n&lt;100$ 点经验了，但是对于杀怪他只留有 $m&lt;100$ 点忍耐度，每杀一个怪会得到相应的 $a_i$ 点经验，但同时也会减少 $b_i$ 点忍耐值，已知 $\text{XHD}$ 最多杀了 $s&lt;100$ 只怪物，当忍耐值降到 $0$ 或以下时，他就不会再玩这款游戏了，他能升到最后一级吗，若能，则输出保留的最大忍耐度，否则输出 $-1$</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k,s,n,m;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complete</span><span class="params">(<span class="keyword">int</span> cost1, <span class="keyword">int</span> cost2, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cost1; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = cost2; j&lt;=s; j++)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i-cost1][j-cost2]+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;s) == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,value;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=k; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;value,&amp;a);</span><br><span class="line">            Complete(a, <span class="number">1</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[m][s] &lt; n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">            <span class="keyword">if</span>(dp[i][s] &gt;= n)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m-i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;     <span class="comment">// 枚举最低的忍耐值消耗</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Luogu2015-二叉苹果树"><a href="#Luogu2015-二叉苹果树" class="headerlink" title="Luogu2015 二叉苹果树"></a><a href="https://www.luogu.org/problemnew/show/P2015" target="_blank" rel="noopener">Luogu2015 二叉苹果树</a></h4><p><strong>题目描述</strong><br>有一棵苹果树，如果树枝有分叉，一定是分二叉，这棵树共有 $n\le100$ 个结点，树根编号一定是 $1$ ，现在这颗树枝条太多了，需要剪枝，但是一些树枝上长有苹果，给定需要保留的树枝数量，求出最多能留住多少苹果</p><p><strong>算法分析</strong><br>很明显的一点是，若要留住某个节点，那么它的父亲节点必须被留住，否则树不连通属于不合法情况，也就是说，若 $u$ 能被装进背包，当且仅当 $depend(u)$ 被装进背包时成立，显然符合有依赖的背包模型，设一个状态 $dp(u,\,i)$ 表示以 $u$ 为根节点的子树中选择 $i$ 条边的最大收益，选择的边数显然是背包的代价，由于每一条边最多能被选择一次，那么本题就可以转化为树上的01背包模型，易得转移方程为</p><script type="math/tex; mode=display">dp(u,\,i)=\max\limits_{v\in son(u)}\{dp(u,\,i),\,dp(u,\,i-k-1)+dp(v,k)+value_k\}</script><p>其中 $k\in [\,0,\,i-1\,]$<br>在这个在这个方程中有一点值得注意，当我们试图获取状态 $dp(u,\,i)$ 时，会从 $dp(u,\,i-k-1)$ 出转移，既然是在子树中获取 $k$ 条边，为何要减 $1$ 呢？事实上，节点 $u$ 所对应的边的取与不取的情况在该转移中是无法确定的，所以必须减 $1$ 以保证节点 $u$ 被取得，否则 $u$ 的子树的取出均不合法<br>对于大多数的有依赖的背包模型，或称之为树型$\text{DP}$，我们往往需要一维来记录节点编号已确定父子关系，在设计状态时可以优先考虑这一点</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line">Edge e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].next = head[u];</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].wei = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> get)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[u][get]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(get == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>)(dp[u][get] = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!son[u][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>)(dp[u][get] = num[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;get; i++)&#123;</span><br><span class="line">        DP(son[u][<span class="number">0</span>], i);</span><br><span class="line">        DP(son[u][<span class="number">1</span>], get-i<span class="number">-1</span>);</span><br><span class="line">        dp[u][get] = max(dp[u][get], dp[son[u][<span class="number">0</span>]][i]+</span><br><span class="line">                         dp[son[u][<span class="number">1</span>]][get-i<span class="number">-1</span>]+num[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeTree</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> par)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != par)&#123;</span><br><span class="line">            num[v] = e[i].wei;</span><br><span class="line">            son[u][tot++] = v;</span><br><span class="line">            makeTree(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    makeTree(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    DP(<span class="number">1</span>, m+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Luogu2014-选课"><a href="#Luogu2014-选课" class="headerlink" title="Luogu2014 选课"></a><a href="https://www.luogu.org/problemnew/show/P2014" target="_blank" rel="noopener">Luogu2014 选课</a></h4><p><strong>题目描述</strong><br>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，现在有 $n\le300$ 门功课，每门课有个学分，每门课有一门或没有直接先修课，一个学生要从这些课程里选择 $m\le300$ 门课程学习，试求他能获得的最大学分</p><p><strong>算法分析</strong><br>本题与上一题唯一的区别在于不再保证该树为一棵二叉树，只需修改对孩子节点和取的边数的枚举即可</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;;</span><br><span class="line">Edge e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].next = head[u];</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].wei = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        dp[v][<span class="number">1</span>] = e[i].wei;</span><br><span class="line">        DP(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j&gt;=<span class="number">1</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;j; k++)</span><br><span class="line">                dp[u][j] = max(dp[u][j], dp[v][k]+dp[u][j-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m); m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v,&amp;w);</span><br><span class="line">        add(v, i, w);</span><br><span class="line">    &#125;</span><br><span class="line">    DP(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="number">0</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="HDU3535-AreYouBuzy"><a href="#HDU3535-AreYouBuzy" class="headerlink" title="HDU3535 AreYouBuzy"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3535" target="_blank" rel="noopener">HDU3535 AreYouBuzy</a></h4><p><strong>题目描述</strong><br>你需要在时间 $t\le100$ 内完成 $n\le100$ 组任务，每组任务有 $m\le100$ 个小任务和一个任务类型(0表示本组中所有小任务至少要做1个任务，1表示至多做1个任务，2表示没有限制)，每个小任务需要占用一点时间 $c_i\le100$ 并带来一些收益 $g_i\le100$ ，试求能否按任务类型要求完成所有任务，若能够完成，则输出最大收益，否则输出 $-1$</p><p><strong>算法分析</strong><br>本题考察分组背包的综合运用，设状态 $dp(i,\,j)$ 表示前 $i$ 个任务组花费时间 $j$ 的最大收益，对于三种任务组类型需要分别讨论</p><p>对于 $s=0$ 的情况，由于给出的组有选取下限，那么就需要考虑是否存在一种可能，时间 $t$ 无法完成所有 $s=0$ 的任务组，此时需要输出 $-1$ ，所以就需要将初始值赋为 $-\infty$<br>这种情况下 $dp(i)$ 可能从 $dp(i-1)$ 和 $dp(i)$ 处转移，所以转移方程为</p><script type="math/tex; mode=display">\begin{aligned}dp(i,\,j)&=-\infty \\dp(i,\,j)&=\max\limits_{k=1}^m\{dp(i,\,j),\,dp(i-1,\,j-cost_k)+value_k,\,dp(i,\,j-cost_k)+value_k\}\end{aligned}</script><p>对于 $s=1$ 的情况，至多选取一个任务，整体属于01分组背包模型，直接套用转移方程</p><script type="math/tex; mode=display">\begin{aligned}dp(i,\,j)&=dp(i-1,\,j) \\dp(i,\,j)&=\max\limits_{k=1}^m\{dp(i,\,j),\,dp(i-1,\,j-cost_k)+value_k\}\end{aligned}</script><p>对于 $s=2$ 的情况，组内属于01背包模型，套用转移方程即可</p><script type="math/tex; mode=display">\begin{aligned}dp(i,\,j)&=dp(i-1,\,j) \\dp(i,\,j)&=\max\limits_{k=1}^m\{dp(i,\,j),\,dp(i,\,j-cost_k)+value_k\}\end{aligned}</script><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,t,m,s;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cost[maxn],value[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> stage)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=t; i++)</span><br><span class="line">        dp[stage][i] = -inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j&gt;=cost[i]; j--)&#123;</span><br><span class="line">            dp[stage][j] = max(dp[stage][j], dp[stage][j-cost[i]]+value[i]);</span><br><span class="line">            dp[stage][j] = max(dp[stage][j], dp[stage<span class="number">-1</span>][j-cost[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> stage)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=t; i++)</span><br><span class="line">        dp[stage][i] = dp[stage<span class="number">-1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j&gt;=cost[i]; j--)</span><br><span class="line">            dp[stage][j] = max(dp[stage][j], dp[stage<span class="number">-1</span>][j-cost[i]]+value[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">(<span class="keyword">int</span> stage)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=t; i++)</span><br><span class="line">        dp[stage][i] = dp[stage<span class="number">-1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j&gt;=cost[i]; j--)</span><br><span class="line">            dp[stage][j] = max(dp[stage][j], dp[stage][j-cost[i]]+value[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;t) == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;s);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;cost[j],&amp;value[j]);</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line">                solve1(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">1</span>)</span><br><span class="line">                solve2(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">2</span>)</span><br><span class="line">                solve3(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(<span class="number">-1</span>, dp[n][t]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Luogu1336-最佳课题选择"><a href="#Luogu1336-最佳课题选择" class="headerlink" title="Luogu1336 最佳课题选择"></a><a href="https://www.luogu.org/problemnew/show/P1336" target="_blank" rel="noopener">Luogu1336 最佳课题选择</a></h4><p><strong>题目描述</strong><br>$\text{Matrix67}$ 要写 $n\le200$ 篇论文，这些论文的题目将从 $m\le20$ 个课题中选择，对于第 $i$ 个课题有两个参数 $A_i$ 和 $B_i$ ，当选用该课题写 $x$ 篇论文时，需耗费时间 $A_i\times x^{B_i}$ ，试求 Matrix67 完成 $n$ 篇论文时间的最小花费</p><p><strong>算法分析</strong><br>本题考点为分组背包+完全背包+泛化物品，较综合但难度并不高。考虑设计状态 $dp(i,\,j)$ 表示前 $i$ 个课题中写了 $j$ 篇论文的最小时间花费，那么应该存在转移</p><script type="math/tex; mode=display">dp(i,\,j)=\min\limits_{k=0}^{j}\{dp(i-1,\,j-k)+A_i\times k^{B_i},\,dp(i,\,j)\}</script><p>据此分组背包+完全背包转移即可</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">21</span>],B[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">21</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>)</span><br><span class="line">            ans *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;A[i],&amp;B[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;=j; k++)&#123;</span><br><span class="line">                ll times = A[i]*qpow(k, B[i]);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> || dp[i][j] == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j-k]+times;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(dp[i][j], dp[i<span class="number">-1</span>][j-k]+times);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp[m][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一类简单的背包问题</title>
      <link href="/BasicBackpackProblem/"/>
      <url>/BasicBackpackProblem/</url>
      
        <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h4><p>动态规划 $\text{(DP, Dynamic Programming)}$ 是求解决策过程的一种最优化数学方法，属于运筹学，常用于解决在一定条件下的最优解问题</p><h4 id="动态规划如何工作"><a href="#动态规划如何工作" class="headerlink" title="动态规划如何工作"></a>动态规划如何工作</h4><p>动态规划的基本思路是将整体的任务细分为多个阶段，每个阶段处理与整体任务类似的小任务，在每个阶段做完决策后可以得到该阶段内的一个最优解，再通过整体决策获取全局最优解</p><h4 id="动态规划使用条件"><a href="#动态规划使用条件" class="headerlink" title="动态规划使用条件"></a>动态规划使用条件</h4><p>正如上面所提到，动态规划解决问题的方式是拆分问题，进行多阶段决策以获取全局决策，所以若要使用动态规划，就要使得该模型满足 <strong>无后效性原则</strong> ，即任何一个阶段中的决策不会改变其他任意阶段的决策，或者说 “未来与过去无关” ，否则无法使用动态规划处理问题<br>同样，动态规划还需满足 <strong>最优性原则</strong> ，即问题需具有最优子结构的性质，否则无法通过阶段中的最优决策推断出正确的全局最优决策</p><p>动态规划是解决最优性问题的强而有力的工具，且有许多成型的模型可供使用，本文中将对背包模型的基础内容进行一定介绍</p><h4 id="状态与转移"><a href="#状态与转移" class="headerlink" title="状态与转移"></a>状态与转移</h4><p>在所有的动态规划问题中，我们习惯将划分出的阶段称为 <strong>状态</strong> ，将状态与状态直接的决策变化称为 <strong>转移</strong> ，做出全局最优决策的过程，本质上就是状态转移的过程，我们称让状态正确转移的方法为 <strong>状态转移方程</strong> ，有时也将其简称为 <strong>转移方程</strong></p><h4 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h4><p>为了更好理解下文的内容，在此先介绍何为背包<br>对于背包模型，常见的是存在 $n$ 种物品，每个种物品有着各自的一个代价 $cost_i$ 和一个收益 $value_i$ ，提供一个容量为 $V$ 的背包，要求出一种装物品的方法使得获得的收益 $W$ 最大并求出最大收益</p><h3 id="01背包模型"><a href="#01背包模型" class="headerlink" title="01背包模型"></a>01背包模型</h3><h4 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h4><p>$01$背包是最基础的背包模型，特点是每种物品有且仅有 $1$ 件，对于每一种物品只能选择放或不放进背包，要求求出最大收益</p><h4 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h4><p>首先确定状态，定义 $dp(i,\,j)$ 的含义为：当取到第 $i$ 个物品且背包占用的空间为 $j$ 时，取得的最大的收益 $W$<br>由此定义，显然可以得出他的状态转移方程为</p><script type="math/tex; mode=display">dp(i,\,j)=max\{\,dp(i-1,\,j)\,,dp(i-1,\,j-cost_i)+value_i\,\}</script><p>简单解读这个转移方程，为了获取当前状态 $dp(i,\,j)$ 的最优值，考虑从前面的状态进行转移，对于第 $i$ 个物品，显然只有选或不选两种情况存在，$dp(i-1,\,j)$ 即是不选的情况，此时背包所装的容量不变，无需增加收益。而对于后一种状态，则是将第 $i$ 个物品装进背包的情况，由于当前的耗费的容量为 $j$ 且当前装进物品的代价为 $cost_i$ ，那么就应该从耗费容量为 $j-cost_i$ 处开始向当前状态转移<br>由此转移方程就不难写出该模型的代码了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j&gt;=cost[i]; j--)</span><br><span class="line">        dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-cost[i]]+value[i]);</span><br></pre></td></tr></table></figure></p><h4 id="复杂度分析与优化"><a href="#复杂度分析与优化" class="headerlink" title="复杂度分析与优化"></a>复杂度分析与优化</h4><p>在上面的状态转移方程中，不难发现这种做法的时间复杂度都是 $O(nV)$ 的，显然时间方面难以优化，因为遍历容量与物品是必然的，所以考虑优化空间</p><p>再次看到我们的转移方程</p><script type="math/tex; mode=display">dp(i,\,j)=max\{\,dp(i-1,\,j)\,,dp(i-1,\,j-cost_i)+value_i\,\}</script><p>不难发现，对于第 $i$ 个状态，有且仅有第 $i-1$ 个状态会对其产生影响，那么考虑去掉数组的第一维，现在代码就变成了这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j&gt;=cost[i]; j--)</span><br><span class="line">        dp[j] = max(dp[j], dp[j-cost[i]]+value[i]);</span><br></pre></td></tr></table></figure><br>在此代码中，$dp<em>j$ 同时表示了 $dp(i,\,j)$ 和 $dp(i-1,\,j)$ ，且 $dp</em>{j-cost<em>i}$ 表示 $dp(i-1,\,j-cost_i)$ ，为了保证当枚举到 $dp(i,\,j)$ 时 $dp(i-1,\,j)$ 和 $dp(i-1,\,j-cost_i)$ 是已知的，此处的枚举量 $j$ 必须逆序枚举，且保证了 $dp</em>{j-cost_i}$ 不会表示为 $dp(i,\,j-cost_i)$ ，该结论比较显然，留给读者自行思考，此处不给出证明</p><p>由此，$01$背包模型的空间复杂度已经降至 $O(V)$ ,完成了优化任务</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>上面已经介绍完毕了$01$背包模型的转移是如何进行的，接下来再关注一个比较关键的问题——初始化</p><p>基于纯$01$背包模型常有两种问题，两种问题的共同点是均要求求出最大收益，区别在于对背包容量的限制<br>一类问题只要求出可获得的最大收益，此时只需将 $dp$ 数组赋值为 $0$ 即可，这种情况下<br>对于另一类问题，要求必须恰好装满背包，此时就只能将 $dp_0$ 赋为 $0$ ，而其他元素的初值应为 $-\infty$ ，此类问题输出答案时，应该判断是否合法</p><h3 id="完全背包模型"><a href="#完全背包模型" class="headerlink" title="完全背包模型"></a>完全背包模型</h3><h4 id="模型简介-1"><a href="#模型简介-1" class="headerlink" title="模型简介"></a>模型简介</h4><p>同样是背包的基础模型，与$01$背包模型不同的是，完全背包模型中 $n$ 中物品都可以取无限次</p><h4 id="模型分析-1"><a href="#模型分析-1" class="headerlink" title="模型分析"></a>模型分析</h4><p>状态设计与01背包相同，我们直接考虑转移</p><script type="math/tex; mode=display">dp(i,\,j)=\max\limits_{0\le\,k*cost_i\le\,j} dp(i-1,\,j-k*cost_i)+k*value_i</script><p>通过该方程我们可以写出下面这段代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j&gt;=cost[i]; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;=j/cost[i]; k++)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-k*cost[i]]+k*value[i]);</span><br></pre></td></tr></table></figure></p><h4 id="复杂度分析与优化-1"><a href="#复杂度分析与优化-1" class="headerlink" title="复杂度分析与优化"></a>复杂度分析与优化</h4><p>不难从上面呢的代码中发现，这种处理完全背包的方式的时间复杂度为 $O(nV)$ ，但与01背包不同的是，完全背包还存在一个常数 $\frac{V}{cost_i}$ ，并不理想，考虑优化</p><p>一种方式是删除物品，即对于任意两个物品 $i,\,j$ ，若存在关系 $cost_i&lt;cost_j$ 成立的同时也有 $value_j&lt;value_i$ 成立 ，那么物品 $j$ 就可以被删除掉，因为 $j$ 的 “性价比” 更低<br>这个优化的预处理复杂度是 $O(n^2)$ 的，一般情况下可以接受，且对于随机数据有着较高的效率，但面对刻意设计的数据，极有可能出现一个物品都无法删除的情况，白白浪费了时间</p><p>另一种优化思路，是先将收益大于 $V$ 的物品去除，在计算出代价相同的物品的最大收益，预处理复杂度 $O(n+V)$</p><p>这两种简单的优化思路思维难度较低，且优化程度不明，均通过预处理来试图降低转移时的枚举量，但是在实际运行中有时并不能时实际运行时间降低，下面将引出两种运用$01$背包的思路来优化完全背包的方法</p><h4 id="二进制拆分"><a href="#二进制拆分" class="headerlink" title="二进制拆分"></a>二进制拆分</h4><p>虽然完全背包每一种物品都能取无限多次，但在背包空间的限制情况下，显然对于第 $i$ 种物品，最多能取 $p=\frac{V}{cost_i}$ 次，我们对 $p$ 个物品 $i$ 进行二进制拆分，将其转化为代价为 $2^k\times cost_i$ 且收益为 $2^k\times value_i$ 的若干个物品，此时已经将问题从完全背包模型转换为了$01$背包模型，可套用$01$背包模型求解</p><h4 id="完全背包的-O-nV-解法"><a href="#完全背包的-O-nV-解法" class="headerlink" title="完全背包的 $O(nV)$ 解法"></a>完全背包的 $O(nV)$ 解法</h4><p>与$01$背包的优化类似，现在我们压掉数组的第一维，得到下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = cost[i]; j&lt;=V; j++)</span><br><span class="line">        dp[j] = max(dp[j], dp[j-cost[i]]+value[i]);</span><br></pre></td></tr></table></figure><br>这种做法显然是 $O(nV)$ 的了，下面我们来思考为什么这样做是对的</p><p>先写出这样做的转移方程，因为它明显与上面给出的转移方程不同</p><script type="math/tex; mode=display">dp(i,\,j)=max\{dp(i-1,\,j)\,,dp(i,\,j-cost_i)+value_i\}</script><p>其实当你注意到第二项的状态是 $dp(i,\,j-cost_i)$ 而不是 $dp(i-1,\,j-cost_i)$ 和 $j$ 的转移顺序时，就应该已经了解这种做法的正确性了，由于状态 $dp(i,\,j)$ 可能从状态 $dp(i,\,j-cost_i)$ 处转移得到，那么 $dp(i,\,j-cost_i)$ 必须优先更新，所以 $j$ 的枚举顺序必须是正向的<br>现在又存在一个问题，为什么这么做能够符合完全背包的性质呢？事实上，状态 $dp(i,\,j-cost_i)$ 转移到 $dp(i,\,j)$ 的过程本质上是将一个物品 $i$ 放入背包的过程，这个过程在 $j$ 的枚举中是可以不断进行的，所以 $i$ 自然也可以被选择多次</p><h3 id="多重背包模型"><a href="#多重背包模型" class="headerlink" title="多重背包模型"></a>多重背包模型</h3><h4 id="模型简介-2"><a href="#模型简介-2" class="headerlink" title="模型简介"></a>模型简介</h4><p>多重背包同样是简单背包模型，在多重背包中多一个参数 $num_i$ ，表示第 $i$ 种物品有 $num_i$ 个可以装进背包，有明确的次数限制</p><h4 id="模型分析-2"><a href="#模型分析-2" class="headerlink" title="模型分析"></a>模型分析</h4><p>状态设计同$01$背包与完全背包，顺着背包基础思想不难得出完全背包的转移方程</p><script type="math/tex; mode=display">\large dp(i,\,j)=\max\limits_{k=0}^{\min(num_i,\,\lfloor\frac{V}{cost_i} \rfloor)}dp(i-1,\,j-k*cost_i)+k*value_i</script><p>转移方程代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j&gt;=cost[i]; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;=num[i]; k++)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-k*cost[i]]+k*value[i]);</span><br></pre></td></tr></table></figure><br>上面代码的复杂度显然是 $O(V\sum num_i)$ 的，考虑优化</p><h4 id="二进制拆分-1"><a href="#二进制拆分-1" class="headerlink" title="二进制拆分"></a>二进制拆分</h4><p>此处思想同完全背包的处理方式，不同的是此时 $p=num_i$ ，将第 $i$ 种物品用二进制拆成 $\log p$ 种物品，再对其进行$01$背包操作，复杂度就降低到了 $O(V\sum \log num_i)$ ，在通常遇见的题目中，该复杂度已经十分优秀了，下面将给出该过程的实现代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOne</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = V; i&gt;=cost; i--)</span><br><span class="line">        dp[i] = max(dp[i], dp[i-cost]+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complete</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cost; i&lt;=V; i++)</span><br><span class="line">        dp[i] = max(dp[i], dp[i-cost]+value);       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiple</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(V &lt;= num*cost)     <span class="comment">// 此特判不影响程序结果，但可以提高程序效率</span></span><br><span class="line">        Complete(value, cost);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; num) k = num;</span><br><span class="line">            ZeroOne(k*value, k*cost);</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        Multiple(value[i], cost[i], num[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h4><p>在上文中我们谈到了多重背包的 $O(V\sum \log num_i)$ 解法，其瓶颈在于求出 $dp(i,\,j)$ 的复杂度为 $O(\log num_i)$ ，要使程序效率达到 $O(nV)$ 就需要在 $O(1)$ 的时间内转移出 $dp(i,\,j)$ ，单调队列作为一种常用的维护单调性$DP$的数据结构，可以帮助我们实现这一点</p><p>我们记 $lim = \min(num_i,\,\lfloor\frac{V}{cost_i} \rfloor)$ ，则多重背包的常规转移方程为</p><script type="math/tex; mode=display">dp(i,\,j)=\max\limits_{k=0}^{lim}dp(i-1,\,j-k*cost_i)+k*value_i</script><p>容易发现一个显然的事实，状态 $dp(i,\,j-k\times cost_i)$ 必然会受 $dp(i,\,j-(k+1)\times cost_i)$ 影响，由此继续进行归纳，状态 $dp(i,\,j)$ 必然会影响状态 $dp(i,\,j+k\times cost_i)$ ，其中 $j+k\times cost\le V$</p><p>由此考虑将我们的转移方程变形<br>记 $d=cost_i,\;a=\lfloor\frac{j}{cost_i}\rfloor,\;b=j\,\%\,cost_i$ ，显然 $a$ 为第 $i$ 个物品全选情况下的个数，且可以得到</p><script type="math/tex; mode=display">j=a\times d+b</script><p>现令 $k^{‘}=a-k$ ，则 $k = a-k^{‘}$ ，将 $j$ 与 $k$ 带入原转移方程得</p><script type="math/tex; mode=display">dp(i,\,j)=\max\limits_{k=0}^{lim}\{dp(i-1,\,a\times d+b-(a-k^{'})\times d)+(a-k^{'})\times value_i\}</script><p>化简该式得</p><script type="math/tex; mode=display">dp(i,\,j)=\max\limits_{k=0}^{lim}\{dp(i-1,\,k^{'}\times d+b)-k^{'}\times value_i\}+a\times value_i</script><p>在状态 $dp(i,\,j)$ 中我们要求得的就是上式的最大值，我们将 $dp(i,\,j)$ 前的所有 $dp(i-1,\,k^{‘}\times d+b)-k^{‘}\times value_i$ 放入一个队列，那么答案就是该队列的最大值加上 $a\times value_i$ ，这个维护最大值的队列就是前文中提到的单调队列<br>综上，我们已经可以写出单调队列优化后的多重背包代码了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, value;</span><br><span class="line">&#125;<span class="built_in">queue</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiple</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = cost, lim = min(num, V/cost);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b&lt;cost; b++)&#123;</span><br><span class="line">        head = tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;=(V-b)/cost; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = k, y = dp[k*d+b]-k*value;</span><br><span class="line">            <span class="keyword">while</span>(head &lt; tail &amp;&amp; <span class="built_in">queue</span>[head].pos &lt; k-lim)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">while</span>(head &lt; tail &amp;&amp; <span class="built_in">queue</span>[tail<span class="number">-1</span>].value &lt;= y)</span><br><span class="line">                tail--;</span><br><span class="line">            <span class="built_in">queue</span>[tail] =  (status)&#123;x, y&#125;;</span><br><span class="line">            tail++;</span><br><span class="line">            dp[k*d+b] = <span class="built_in">queue</span>[head].value+k*value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例题与题解"><a href="#例题与题解" class="headerlink" title="例题与题解"></a>例题与题解</h3><h4 id="Luogu1734-最大约数和"><a href="#Luogu1734-最大约数和" class="headerlink" title="Luogu1734 最大约数和"></a><a href="https://www.luogu.org/problemnew/show/P1734" target="_blank" rel="noopener">Luogu1734 最大约数和</a></h4><p><strong>题目描述</strong><br>选取和不超过 $S\le10^3$ 的若干个不同的正整数，使得所有数的约数 （不含它本身） 之和最大</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)</span><br><span class="line">                sum[i] += j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = S; j&gt;=i; j--)</span><br><span class="line">            dp[j] = max(dp[j], dp[j-i]+sum[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[S]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Luogu1616-疯狂的采药"><a href="#Luogu1616-疯狂的采药" class="headerlink" title="Luogu1616 疯狂的采药"></a><a href="https://www.luogu.org/problemnew/show/P1616" target="_blank" rel="noopener">Luogu1616 疯狂的采药</a></h4><p><strong>题目描述</strong><br>山洞中有 $M\le10^4$ 种草药，每种草药有一个采集时间与价值，每种草药可以无限采摘，请问在一定时间 $T\le10^5$ 内可以获取的最大价值是多少</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,m,cost[maxn],value[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn*<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;cost[i],&amp;value[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = cost[i]; j&lt;=t; j++)</span><br><span class="line">            dp[j] = max(dp[j], dp[j-cost[i]]+value[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="HDU2191-灾区补寄"><a href="#HDU2191-灾区补寄" class="headerlink" title="HDU2191 灾区补寄"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2191" target="_blank" rel="noopener">HDU2191 灾区补寄</a></h4><p><strong>题目描述</strong><br>为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金 $n\le100$ 元，而市场有 $m\le100$ 种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买，试求用一定的资金最多能采购多少粮食</p><p><strong>代码实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m,dp[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> value,cost,num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOne</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i&gt;=cost; i--)</span><br><span class="line">        dp[i] = max(dp[i], dp[i-cost]+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complete</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cost; i&lt;=n; i++)</span><br><span class="line">        dp[i] = max(dp[i], dp[i-cost]+value);       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiple</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> cost, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= num*cost)</span><br><span class="line">        Complete(value, cost);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; num) k = num;</span><br><span class="line">            ZeroOne(k*value, k*cost);</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;cost,&amp;value,&amp;num);</span><br><span class="line">            Multiple(value, cost, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
